//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
//

#include "nesting/application/ethernet/VlanEtherTrafGen.h"
#include "nesting/linklayer/vlan/EnhancedVlanTag_m.h"
#include "nesting/application/ethernet/VlanEtherTrafGenSched.h"

#include "inet/common/TimeTag_m.h"
#include "inet/linklayer/common/Ieee802SapTag_m.h"
#include "inet/linklayer/common/MacAddressTag_m.h"
#include "inet/common/ProtocolTag_m.h"
#include "inet/common/packet/chunk/ByteCountChunk.h"
#include "inet/common/Protocol.h"
#include "inet/common/Simsignals.h"
#include "inet/linklayer/ethernet/EtherFrame_m.h"
#include "inet/common/IProtocolRegistrationListener.h"

namespace nesting {

    Define_Module(VlanEtherTrafGen);

    void VlanEtherTrafGen::initialize(int stage) {
        EtherTrafGen::initialize(stage);

        if (stage == INITSTAGE_LOCAL) {
            vlanTagEnabled = &par("vlanTagEnabled");
            pcp = &par("pcp");
            dei = &par("dei");
            vid = &par("vid");
            gateController = getModuleFromPar<GateController>(
                 par("gateControllerModule"), this);
            string filename = (&par("result_file_location"))->stringValue() ;
            this->result_file.open(filename, ios::out | ios::trunc);
        } else if (stage == INITSTAGE_LINK_LAYER) {
            registerService(*VlanEtherTrafGenSched::L2_PROTOCOL, nullptr, gate("in"));
            registerProtocol(*VlanEtherTrafGenSched::L2_PROTOCOL, gate("out"), nullptr);
        }
    }

    void VlanEtherTrafGen::sendBurstPackets() {
        int n = numPacketsPerBurst->intValue();
        for (int i = 0; i < n; i++) {
            seqNum++;

            char msgname[40];
            sprintf(msgname, "pk-%d-%ld", getId(), seqNum);

            // create new packet
            Packet *datapacket = new Packet(msgname, IEEE802CTRL_DATA);
            long len = packetLength->intValue();
            const auto& payload = makeShared<ByteCountChunk>(B(len));
            // set creation time
            auto timeTag = payload->addTag<CreationTimeTag>();
            timeTag->setCreationTime(simTime());

            datapacket->insertAtBack(payload);
            datapacket->removeTagIfPresent<PacketProtocolTag>();
            datapacket->addTagIfAbsent<PacketProtocolTag>()->setProtocol(VlanEtherTrafGenSched::L2_PROTOCOL);
            // TODO check which protocol to insert
            auto sapTag = datapacket->addTagIfAbsent<Ieee802SapReq>();
            sapTag->setSsap(ssap);
            sapTag->setDsap(dsap);

            // create control info for encap modules
            auto macTag = datapacket->addTag<MacAddressReq>();
            macTag->setDestAddress(destMacAddress);

            // create VLAN control info
            if (vlanTagEnabled->boolValue()) {
                EnhancedVlanReq* vlanReq = datapacket->addTag<EnhancedVlanReq>();
                vlanReq->setPcp(pcp->intValue());
                vlanReq->setDe(dei->boolValue());
                vlanReq->setVlanId(vid->intValue());
            }

            EV_TRACE << getFullPath() << ": Send packet `" << datapacket->getName()
                     << " "
                     << "' dest=" << macTag->getDestAddress() << " length="
                     << datapacket->getBitLength() << "B type="
                     << IEEE802CTRL_DATA << " vlan-tagged="
                     << vlanTagEnabled->boolValue();
            if (vlanTagEnabled->boolValue())
            {
                EV_TRACE << " pcp=" << pcp->intValue() << " dei=" << dei->boolValue() << " vid=" << vid->intValue();
            }
            EV_TRACE << endl;

            emit(packetSentSignal, datapacket);
            send(datapacket, "out");
            packetsSent++;
        }
    }

    void VlanEtherTrafGen::receivePacket(Packet *msg)
    {
        EV_INFO << "Received packet `" << msg->getName() \
        <<  "' length= " << msg->getByteLength() << "B\n" \
        << "src: " << msg->getTag<MacAddressInd>()->getSrcAddress() \
        << " " << "dest: " << msg->getTag<MacAddressInd>()->getDestAddress() << " " << "pcp_value: " \
        << msg->getTag<EnhancedVlanInd>()->getPcp() << " " ;

        // for (auto& region : msg->getAllTags<CreationTimeTag>())
        // EV_INFO << "e2e_delay" << (simTime() - region.getTag()->getCreationTime());
        
        auto data = msg->peekData(); // get all data from the packet
        auto regions = data->getAllTags<CreationTimeTag>(); // get all tag regions
        SimTime delay;
        for (auto& region : regions) { // for each region do
            auto creationTime = region.getTag()->getCreationTime(); // original time
            delay = simTime() - creationTime; // compute delay
            EV_INFO << "e2e_delay" << delay;
        }


        this->result_file << "{ \"time\": "<<simTime() << ", \"src\": \"" << msg->getTag<MacAddressInd>()->getSrcAddress() << "\""\
            << ", \"dest\": \"" << msg->getTag<MacAddressInd>()->getDestAddress() << "\"" \
            << ", \"pcp\": " << msg->getTag<EnhancedVlanInd>()->getPcp() \
            << ", \"e2edelay\": " << delay << " } "   << endl  ;
        
        
        
        simtime_t target_time_interval_1;
        
        // asw 周期内累加制  begin 
        static Schedule<GateBitvector>* currentSchedule = new Schedule<GateBitvector>();
        // asw 周期内累加制  end

        static bool first = true;
        if (first)
        {
            Schedule<GateBitvector>* currentSchedule_1 = gateController->getCurrentSchedule();
            
            // asw 周期内累加制  begin 
            currentSchedule->setBaseTime(currentSchedule_1->getBaseTime());
            currentSchedule->setCycleTime(currentSchedule_1->getCycleTime());
            currentSchedule->addControlListEntry(currentSchedule_1->getTimeInterval(0), currentSchedule_1->getScheduledObject(0));
            currentSchedule->addControlListEntry(currentSchedule_1->getTimeInterval(1), currentSchedule_1->getScheduledObject(1));
            // asw 周期内累加制  end

            first = false;
        }

        
         // AWS 调节算法
        if ( msg->getTag<EnhancedVlanInd>()->getPcp() == 7 && delay > SimTime(75, SIMTIME_US)) 
        {
            // Schedule<GateBitvector>* currentSchedule = gateController->getCurrentSchedule();
            Schedule<GateBitvector> nextSchedule;
            GateBitvector bitvector = currentSchedule->getScheduledObject(0);
            simtime_t time_interval = currentSchedule->getTimeInterval(0);
            simtime_t schedule_cycle = currentSchedule->getCycleTime();
            
            // 两端预留10%, 100, 步进周期5%, 50us 


            // asw 周期内累加制  begin 
            simtime_t target_time_interval = ((time_interval.trunc(SIMTIME_US) + SimTime(10, SIMTIME_US)) > (schedule_cycle * 0.9)) ? (schedule_cycle * 0.9) :  (time_interval.trunc(SIMTIME_US) + SimTime(10, SIMTIME_US));
            // asw 周期内累加制  end


            // simtime_t target_time_interval = ((time_interval.trunc(SIMTIME_US) + SimTime(10, SIMTIME_US)) > (schedule_cycle * 0.9)) ? (schedule_cycle * 0.9) :  (time_interval.trunc(SIMTIME_US) + SimTime(10, SIMTIME_US));

            this->result_file << "{ \"time\": "<< simTime() << ", \"src\": \"" << msg->getTag<MacAddressInd>()->getSrcAddress() << "\""\
            << ", \"dest\": \"" << msg->getTag<MacAddressInd>()->getDestAddress() << "\"" \
            << ", \"pcp\": " << msg->getTag<EnhancedVlanInd>()->getPcp() \
            << ", \"pcp=7-interval\": " << target_time_interval << ", \"pcp<7-interval\": " << SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US) << " } "<< endl;
           
            nextSchedule.addControlListEntry(target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(0));
            nextSchedule.addControlListEntry(SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(1));
            gateController->setNextSchedule(nextSchedule);

            // asw 周期内累加制  begin 
            currentSchedule->setTimeInterval(0, target_time_interval.trunc(SIMTIME_US));
            currentSchedule->setTimeInterval(1, SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US));
            // asw 周期内累加制  end 
        }
        
        // aws原论文将阈值设置为最差可接受时延的50%
        if ( msg->getTag<EnhancedVlanInd>()->getPcp() == 7 && delay < SimTime(75, SIMTIME_US))
        {
            // 修改调度时隙分配, 将流量分为两个, 优先级为7和优先级为其他
            // Schedule<GateBitvector>* currentSchedule = gateController->getCurrentSchedule();
            Schedule<GateBitvector> nextSchedule;
            GateBitvector bitvector = currentSchedule->getScheduledObject(0);
            simtime_t time_interval = currentSchedule->getTimeInterval(0);
            simtime_t schedule_cycle = currentSchedule->getCycleTime();

            // asw 周期内累加制  begin 
            simtime_t target_time_interval = ((time_interval.trunc(SIMTIME_US) - SimTime(10, SIMTIME_US)) < (schedule_cycle * 0.1)) ? (schedule_cycle * 0.1) :  (time_interval.trunc(SIMTIME_US) - SimTime(10, SIMTIME_US));
            // asw 周期内累加制  end



            // 保证不小于总周期的10%, 步进10us, 预留周期10%, 也就是10us
            // simtime_t target_time_interval =  ( time_interval.trunc(SIMTIME_US) - SimTime(10, SIMTIME_US) ) < SimTime(40, SIMTIME_US) ? SimTime(40, SIMTIME_US) :  (time_interval.trunc(SIMTIME_US) - SimTime(10, SIMTIME_US));

            this->result_file << "{ \"time\": "<<simTime() << ", \"src\": \"" << msg->getTag<MacAddressInd>()->getSrcAddress() << "\""\
            << ", \"dest\": \"" << msg->getTag<MacAddressInd>()->getDestAddress() << "\"" \
            << ", \"pcp\": " << msg->getTag<EnhancedVlanInd>()->getPcp() \
            << ", \"pcp=7-interval\": " << target_time_interval << ", \"pcp<7-interval\": " << SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US) << " } "<< endl;

            nextSchedule.addControlListEntry(target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(0));
            nextSchedule.addControlListEntry(SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(1));
            gateController->setNextSchedule(nextSchedule);

            // asw 周期内累加制  begin 
            currentSchedule->setTimeInterval(0, target_time_interval.trunc(SIMTIME_US));
            currentSchedule->setTimeInterval(1, SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US));
            // asw 周期内累加制  end
        }
        
        
        /*
        // 反馈调节算法
        // 判断pcp=7的流量延时情况, 延迟 > 120us了(80%), 决定是否调整窗口, st流时延上限设为150us
        if ( msg->getTag<EnhancedVlanInd>()->getPcp() == 7 && delay > SimTime(110, SIMTIME_US)) 
        {
            // 修改调度时隙分配, 将流量分为两, 优先级为7和优先级为其他
            Schedule<GateBitvector>* currentSchedule = gateController->getCurrentSchedule();
            Schedule<GateBitvector> nextSchedule;
            GateBitvector bitvector = currentSchedule->getScheduledObject(0);
            simtime_t time_interval = currentSchedule->getTimeInterval(0);
            simtime_t schedule_cycle = currentSchedule->getCycleTime();
            double scale = delay.dbl() / SimTime(0.00005).dbl();

            // 保证不大于调度调节周期
            simtime_t target_time_interval =  ((scale * time_interval) > schedule_cycle * 0.95) ? (schedule_cycle * 0.95) :  (scale * time_interval);

            this->result_file << "{ \"time\": "<< simTime() << ", \"src\": \"" << msg->getTag<MacAddressInd>()->getSrcAddress() << "\""\
            << ", \"dest\": \"" << msg->getTag<MacAddressInd>()->getDestAddress() << "\"" \
            << ", \"pcp\": " << msg->getTag<EnhancedVlanInd>()->getPcp() \
            << ", \"pcp=7-interval\": " << target_time_interval << ", \"pcp<7-interval\": " << SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US) << " } "<< endl;

            // this->result_file << endl << "cycle " <<  schedule_cycle   << "   current time_interval: " << time_interval << "   ---------------0 internal " << target_time_interval << "=====1 internal   " << (SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US)) << endl;
            
            nextSchedule.addControlListEntry(target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(0));
            nextSchedule.addControlListEntry(SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(1));
            gateController->setNextSchedule(nextSchedule);
        }
        
        // 判断pcp=7的流量延时情况, 延迟阈值设置与0.2 * 最大可接受时延, 调小st流量窗口
        if ( msg->getTag<EnhancedVlanInd>()->getPcp() == 7 && delay < SimTime(20, SIMTIME_US)) 
        {
            // 修改调度时隙分配, 将流量分为两个, 优先级为7和优先级为其他
            Schedule<GateBitvector>* currentSchedule = gateController->getCurrentSchedule();
            Schedule<GateBitvector> nextSchedule;
            GateBitvector bitvector = currentSchedule->getScheduledObject(0);
            simtime_t time_interval = currentSchedule->getTimeInterval(0);
            simtime_t schedule_cycle = currentSchedule->getCycleTime();
            // 如果时延太小, 就把目标时延设置到75us的程度
            double scale = delay.dbl() / SimTime(0.00006).dbl();

            // this->result_file << "time_interval: " << time_interval << endl;

            // 保证不小于初始时间窗口
            simtime_t target_time_interval =  ((scale * time_interval).trunc(SIMTIME_US) < SimTime(40, SIMTIME_US)) ? SimTime(40, SIMTIME_US) :  (scale * time_interval).trunc(SIMTIME_US);
            
            this->result_file << "{ \"time\": "<<simTime() << ", \"src\": \"" << msg->getTag<MacAddressInd>()->getSrcAddress() << "\""\
            << ", \"dest\": \"" << msg->getTag<MacAddressInd>()->getDestAddress() << "\"" \
            << ", \"pcp\": " << msg->getTag<EnhancedVlanInd>()->getPcp() \
            << ", \"pcp=7-interval\": " << target_time_interval << ", \"pcp<7-interval\": " << SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US) << " } "<< endl;

            // target_time_interval = target_time_interval < SimTime(15, SIMTIME_US) ? SimTime(15, SIMTIME_US)
            // this->result_file << endl << "cycle " <<  schedule_cycle   << "   current time_interval: " << time_interval << "   ---------------0 internal " << target_time_interval << "=====1 internal   " << (SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US)) << endl;

            nextSchedule.addControlListEntry(target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(0));
            nextSchedule.addControlListEntry(SimTime(100, SIMTIME_US) - target_time_interval.trunc(SIMTIME_US), currentSchedule->getScheduledObject(1));
            gateController->setNextSchedule(nextSchedule);
        }
        */

        packetsReceived++;
        emit(packetReceivedSignal, msg);
        delete msg;
    }

} // namespace nesting
